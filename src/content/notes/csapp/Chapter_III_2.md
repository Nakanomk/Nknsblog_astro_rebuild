---
title: 'Chapter III-2'
description: 'CSAPP NOTE CHAP III-2'
order: 4
---

# Chapter 3.2 IA-32 指令系统概述

## 数据类型及其格式

IA-32 指令系统中，操作数可以按存储方式分为：

- 立即数
- 寄存器操作数
- **存储器操作数**

注：IA-32 指令系统中，操作数被看作 0/1 序列

> AT&T 格式和 Intel 格式的汇编指令有不小的区别：
>
> | Intel格式    | AT&T格式             |
> | ------------ | -------------------- |
> | MOV EAX, 0   | **movl  $0, %eax**   |
> | ADD EAX, EBX | **addl**  %ebx, %eax |
> | INC ECX      | **incl**  %ecx       |
>
> 两者目的操作数和源操作数的顺序不同！

### AT&T 指令长度后缀

| 后缀 | 操作数 | 例子           |
| ---- | ------ | -------------- |
| b    | 8位    | movb $0， %al, |
| w    | 16位   | movw  $0, buf  |
| l    | 32位   | movl $0, %eax  |

**若指令中有一个操作数是寄存器，则操作数长度已确定，长度后缀可省略（不推荐）**

### 寄存器组织

![image-20251026123928449](https://img.nkns.cc/PicGo/image-20251026123928449.png)

### 寻址方式

1. 主存储器

|          | 主存 | 辅存 |
| -------- | ---- | ---- |
| 容量     | 小   | 大   |
| 存取速度 | 快   | 慢   |

- 基本单位是 bit
- 为了区别各个存贮单元，给每个单元编号，称为**地址**
  - **字节**单元的编号，也称为物理地址
  - 低字节放地位，高字节放高位

![image-20251026124203772](https://img.nkns.cc/PicGo/image-20251026124203772.png)

![image-20251026124408496](https://img.nkns.cc/PicGo/image-20251026124408496.png)

### 存储器物理地址的形成

早期的 8086 微处理：

- 20 位地址总线，寻址范围：$$ 2^{20} = 1M $$ 
- 与地址相关的寄存器均为 16 位（SP, BP, SI, DI)，寻址范围：$$ 2^{16} = 64K$$ 

问题：如何通过 16 位寄存器访问 1 MB 的内存

解决：将 1 M 字节主存分段，每段最多 64 K 字节

- 用 CS, DS, SS, ES 保存当前可用段的段首地址

- 计算物理地址时，应将段寄存器内容左移 4 位，然后再与偏移地址相加，得到待访问单元的物理地址。

![image-20251026125908224](https://img.nkns.cc/PicGo/image-20251026125908224.png)

80x86 的寻址范围：

- 80x86 地址总线 32 位，寻址范围 4 G
- 80x86 通用寄存器 32 位，寻址范围也是 4 G

所以 80x86 的一个通用寄存器能够存放一个完整的 32 位地址

### 保护模式下的内存管理

要为每个进程提供一个独立的4G大小的虚拟地址空间。逻辑地址空间（多个进程的地址空间总和）大于物理地址空间。采用**分页机制**来实现：

- 将物理地址映射到进程的逻辑地址空间上；

- 只有映射了物理内存的逻辑地址空间才能访问；

- 每次映射的物理内存不大，且用完后可释放，再重新映射到新的逻辑地址空间上，因此能够让多个进程同时运行；

- 分页由系统基于页目录和页表，自动完成

![image-20251026130228471](https://img.nkns.cc/PicGo/image-20251026130228471.png)

特权级与**分段机制**

1. 80x86有4个特权级：0,1,2,3（0级**最高**，3级**最低**），能够在虚拟内存的基础上实现进一步的内存保护机制

![image-20251026130514801](https://img.nkns.cc/PicGo/image-20251026130514801.png)

2. 80x86通过**分段机制**来实现特权级的访问控制。

   用“**段选择符**：EA”的形式表示逻辑地址，段选择符（16位）存放在段寄存器中，指向一个**段描述符**（64位）

![image-20251026130500434](https://img.nkns.cc/PicGo/image-20251026130500434.png)

用逻辑地址访问内存时，段选择符中的特权级需要高于段描述符中的**特权级**。

3. 由逻辑地址生成物理地址的过程：

![image-20251026131624700](https://img.nkns.cc/PicGo/image-20251026131624700.png)

- EA要小于“段界限 * 4K”。一般应用程序中，段基址为0，段界限为0FFFFFH。所以对线性地址的形成不产生影响。

### 具体寻址方式（重要）

![image-20251026131700566](https://img.nkns.cc/PicGo/image-20251026131700566.png)

1. **立即寻址**

   操作数直接存放在指令中，紧跟在操作码之后，它作为指令的一部分存放在代码段里，这种操作数称为立即数。

   汇编格式：$value

   功能：指令的下一单元的内容为操作数 n，即：

   ![image-20251026131902152](https://img.nkns.cc/PicGo/image-20251026131902152.png)

**例子** movl $0x3064, %eax

目的操作数采用寄存器寻址，为寄存器 eax

源操作数采用立即寻址，即：

![image-20251026132347724](https://img.nkns.cc/PicGo/image-20251026132347724.png)

注意事项：

- 立即数指令作为源操作数，**不能作为目的操作数**！

- 立即数**不能作为单操作数指令的操作数**
- 立即数**只有大小，没有类型，未分配内存单元**

2. **寄存器寻址**

​	在这种寻址方式中，指令所指明的寄存器中存放操作数

​	汇编格式：%R 

​	功能：寄存器R的内容就是操作数。

![image-20251026132547362](https://img.nkns.cc/PicGo/image-20251026132547362.png)

**例子 1**

`incl %eax`

​	操作数在 eax 中

![image-20251026132620740](https://img.nkns.cc/PicGo/image-20251026132620740.png)

​	执行前：EAX=12H

​	执行：EAX+1 → EAX。

​	执行后：EAX= 13H

**例子 2**

`add %ebx, %eax`

​	EAX为目的操作数地址，EBX为源操作数地址。

![image-20251026132715349](https://img.nkns.cc/PicGo/image-20251026132715349.png)

​	执行前：EAX=1234H，EBX=5620H

​	执行： EAX+EBX→ EAX。

​	执行后：EAX=6854H，EBX=5620H

​	目的操作数、源操作数都是用寄存器寻址

注意事项：

- 用寄存器操作比较快！如果可能的话尽量多用
- 采用寄存器寻址方式，**目的、源操作数类型必须一致**。如：movw %bx, %ah; ERROR

3. **直接寻址**
4. 
