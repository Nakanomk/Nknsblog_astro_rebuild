---
title: 'Chapter II'
description: 'CSAPP NOTE CHAP II'
order: 2
---

# Chap 2 数据的机器级表示和处理

## 编码和数制

### 计算机系统层次中的编码任务

![image-20251022222836429](https://img.nkns.cc/PicGo/image-20251022222836429.png)

- 在不同的层次中实现各自的编码
- 在不同的层次间实现编码的映射

**例如**

- C 语言中有 `short` `int` 等类型
- 汇编语言 (ISA 层) 中有 `BYTE` `WORD` `DWORD` 等类型。每种类型只考虑编码长短。
- 可以采用补码、原码等编码，将高级语言中的有符号整数，映射为 ISA 层中指定长度的码点。

### 外部信息与内部数据的转换

从不同的角度和层次来看，数据有不同的形态。

![image-20251023120559036](https://img.nkns.cc/PicGo/image-20251023120559036.png)

### 码点和码点空间

1. 数据存储的单位和宽度
   - bit 0 或 1
   - byte 8 位一个字节，寻址单位
   - word 2 个 byte
   - dword 2 个 word
2. 存储容量单位
   - KB：2^10 字节
   - MB：2^20 字节
   - GB：2^30 字节
   - TB：2^40 字节
   - PB：2^50 字节

3. 码点空间

   针对一个位数为 n 的存储单元，它的每一种状态共同组合成了它的码点空间

   n bit 的存储，提供 $$ 2^n $$ 种不同的状态

**例子**

一个 16 位的存储单元，它的码点空间为：

| 二进制              | 十六进制 | 十进制 |
| ------------------- | -------- | ------ |
| 0000 0000 0000 0000 | 0000H    | 0      |
| 0000 0000 0000 0001 | 0001H    | 1      |
| ……                  | ……       |        |
| 1010 1011 1012 1013 | ABCDH    | 43981  |
| ……                  |          |        |
| 1111 1111 1111 1111 | FFFFH    | 65536  |

从ISA的层次来理解：

- 存储单元的“码点”的编码，只是为了区分存储单元的不同状态。

- 存储单元的“码点”的编码，不具有语义上的含义。

- 存储单元的“码点”，需要从软件层次出发，可以和上层软件编程中的语义数值进行一一对应。例如一个“码点”，进行对应后，可以表示一个整数、一个正数、一个负数、一个浮点数、或一个字符。

- 对存储单元的语义的指定，是依靠在指令中，使用不同的操作符实现的。

  例如：

  * IMUL AX; 有符号乘法，将AX看作有符号数

  - MUL AX； 无符号乘法，将AX看作无符号数

### 编码方案

将语义数据和“码点”进行映射，即对数据进行编码。有许多种不同编码方案。这里不列举。

## 数值数据的机内表示

![image-20251023165454595](https://img.nkns.cc/PicGo/image-20251023165454595.png)

### 有符号整数

- 一个包含正负整数的集合，例如 {-128, -127, ..., 0, ...,127}

- 一般用补码表示

1. 整数的补码：它本身的二进制数。

   例如：45 用 8 位补码表示： `0010 1101`

2. 负数的补码：

   负数 X 的补码 = 2n - |X|，其中 n 位字长。（最高位为 1 表示负数）

   如：n = 8 时，-45 的补码为：`1101 0011` 

   简单方法：X 的补码 = |X| 的二进制数取反 + 1

3. 补码的表示范围

   字长为 n 的补码表示范围：

   -2^(n-1) ~ +(2^(n-1) - 1)

   **这是因为补码结构类似：**

   **0000 0000 (0) -> 7FFF FFFF (2147483647) -> 8000 0000 (-2147483648) -> FFFF FFFF (-1)**

4. 补码的运算特点

   [m + n]_ 补 = [m]_ 补 + [n]_ 补

   相反数的补码为 -n 的补码的补码

### 无符号整数

- 一个只包含非负整数的集合
- 用原码表示

字长为 n 的原码表示范围：0 ~ 2^(n) - 1

### 浮点数

![image-20251023170450031](https://img.nkns.cc/PicGo/image-20251023170450031.png)

这是浮点数的基本表示，下面进行详细讲解。

![image-20251023170458656](https://img.nkns.cc/PicGo/image-20251023170458656.png)

- 符号位：0 表示正数，1 表示负数
- 指数：一个字节用来表示指数
- 指数是采用的“移码”来表示的：n - 127

| 指数码点   | 指数值                                                       |
| ---------- | ------------------------------------------------------------ |
| 0000  0000 | 特殊值，尾数为0时表示0；否则表示一个非规格化的小数（ 2-126(0.f)） |
| 0000  0001 | -126                                                         |
| n          | n-  127                                                      |
| 1111  1110 | +127                                                         |
| 1111  1111 | 特殊值，尾数为0时表示¥；否则表示NaN                          |

- 尾数：规格化数据中，尾数值为 1.XXXX

​	例：

​		float d1 = -0.75；

​	(-0.75) = -0.11B = - 1.1B * 2^-1

​	符号位：1

​	指数：n – 127 = -1， n = 126 = 0111 1110B

​	尾数：1B

​	d1的二进制表示：1 0111 1110 1000 0000 0000 0000 0000 000B

​	对应的4字节内容：BF F4 00 00 00 00 00 00H

### 十进制数（不考，看个乐子）

用二进制数来表示十进制数，80x86 提供直接处理 BCD 码的指令。

如：		98 = 1001 1000BCD

压缩 BCD码	9781 = 1001 0111 1000 0001

非压缩BCD码	9781 = 00001001 00000111 00001000 00000001

## 字符数据的机内表示

- 字符编码：字符集到“码点空间”的映射
- 西文字母采用 ASCII 码（老生常谈了属于是）

![image-20251023171024701](https://img.nkns.cc/PicGo/image-20251023171024701.png)

- 汉字字符一般用 Unicode 或者 GBK

### 字符串的存放

以下是以字符串 "1234ABCD" 为例的存放结构

![image-20251023171122380](https://img.nkns.cc/PicGo/image-20251023171122380.png)
