---
title: 'Week 1'
publishDate: 2025-09-02 14:23:53
description: 'Records About DM Week1'
tags:
  - Code  - Learn
language: '中文'
heroImage: { src: '../../../public/covers/Wanlingce.jpg', color: '#edb9a2' }
---
# Week 1 数论和密码学

## 整除

### 定义

如果 a 和 b 是整数 且 a ≠ 0, 那么如果存在一个整数 c， 使得 b = ac， 则称 a 整除 b， 记为 $ a\ |\ b $

- 当 a 整除 b 时，我们称 a 是 b 的 **因数** 或 **除数**，并且称 b 是 a 的 **倍数**
- 如果 $ a\ |\ b $，那么 $\frac{b}{a}$ 是一个整数
- 如果 a 不整除 b，我们记作 $ a\ \nmid\ b $

### 例题

判断 $3\mid7$ 和 $3\mid12$ 是否成立.

### 例题解答

- $3\nmid7$ 因为 $\frac{7}{3}$ 不是整数
- $3\mid12$ 因为 $\frac{12}{3}$ 是整数

### 定理

- **线性组合性** 如果 $ a\mid b$ 且 $a\mid c$，那么 $a\mid (b+c)$.
- 如果 $ a\mid b$ ，那么对于所有的整数 c，$a\mid bc$.
- **传递性** 如果 $ a\mid b$ 并且 $b\mid c$ ，那么 $a\mid c$.
- **大小关系** 如果 $ a\mid b$ ，$b\neq 0$ ，那么 $\lvert{a}\rvert\leq\lvert{b}\rvert$.

### 推论

若 $ a, b, c$ 是整数，且 $a\neq 0$ ，且 $ a\mid b$ 和 $a\mid c$ ，则对任意整数 $m$ 和 $n$ ，$a\mid (mb + nc)$ .

### 练习

证明：如果 $c\mid(a-b)$，$c\mid (a'-b')$ ，那么 $c\mid(aa'-bb')$

## 除法算法

当一个整数被一个正整数除时，会得到一个商和一个余数.这通常被称为“除法算法”（Division Algorithm），但实际上它是一个定理.

### 定义

如果 $a$ 是一个整数，$b$ 是一个正整数，那么存在唯一的整数 $q$ 和 $r$，使得 $0\leq r< b$，并且 $a = bq+r$.

对于得数，我们有这样的定义：

$$
\left\{
\begin{aligned}
q&= a\ div\ b\\
r&= a\ mod\ b
\end{aligned}
\right.
$$
由于相关的定理证明太过于复杂以及难懂，这里略过了。

## 同余关系

### 定义

如果 a 和 b 是整数，且 m 是正整数，那么当 m 整除 a-b 时，称 a 与 b 在模 m 下同余。
$$
a\equiv b\pmod{m}
$$

### 例题

判断 17 是否在模 6 意义下与 5 同余，24 和 14 是否在模 6 意义下同余.

### 解答

太简单了，略去

### 定理

设 m 为正整数。当且仅当存在一个整数 k 使得 $$ a = b + km $$ ，整数 a 和 b 在模 m 下同余

### 性质

**自反性** 任何正整数都和它自身同余 $$ a\equiv a \pmod{m} $$

**对称性** $$ a\equiv b \pmod{m} \Rarr b\equiv a\pmod{m}$$

**传递性** $$ a\equiv b \pmod{m},b\equiv c\pmod{m}\Rarr a\equiv c\pmod{m}$$

## 同余式的加和乘

### 定理

设 m 为正整数。如果 $$ a\equiv b \pmod{m}$$ 且 $$ c\equiv d\pmod{m}$$ 则 $$ a+c\equiv b +d\pmod{m}$$ ，$$ ac\equiv bd \pmod{m}$$ 且 $$ a^k\equiv b^k \pmod{m} $$。其中 k 是非负整数。

### 备注

这条定理主要强调了同余关系的加法和乘法具有可叠加性。从这个角度想的话这个定理就很自然，所以证明就先略过了。

## 同余式的代数运算

- 将有效同余的两边同时乘以一个整数会保持其有效性。
- 将一个整数加到有效同余的两边也会保持其有效性。

- 然而，将同余两边同时**除以**一个整数并**不**总能产生有效的同余关系。

### 计算 mod m 函数的和与积

**定理** 设 m 为正整数，a 和 b 为整数。那么
$$
\left\{
\begin{aligned}
(a+b)\pmod{m}&= ((a\bmod m) + (b\bmod m))\bmod m\\
ab\bmod m &=((a\bmod m)(b\bmod m))\bmod m
\end{aligned}
\right.
$$
如此便可以将一个数字拆分成它的因数和一部分进行模运算再相加或相乘

## 二进制模幂算法

这个算法实际上是借助了上面这个定理进行的。因为任意数的二进制展开是存在且唯一的，所以利用快速幂以及模运算的乘法可拆性就可以将幂次的二进制展开每一位对应的模幂计算出来相乘再取模。

举个例子更加直观一点

### 例子

 $$ 2^{644} \bmod 645$$

### 解答

首先，将幂次进行二进制展开
$$
(644)_{10}=(1010000100)_2
$$
之后对每一个二进制位对应的数字进行计算

**这里的power初始值为 2**，这么写是为了最后每一行的 a 为 1 时乘以上一行对应的 power 方便 

| i    | $$a_i$$ | power | x    |
| ---- | ------- | ----- | ---- |
| 0    | 0       | 4     | 1    |
| 1    | 0       | 16    | 1    |
| 2    | 1       | 256   | 16   |
| 3    | 0       | 391   | 16   |
| 4    | 0       | 16    | 16   |
| 5    | 0       | 256   | 16   |
| 6    | 0       | 391   | 16   |
| 7    | 1       | 16    | 451  |
| 8    | 0       | 256   | 451  |
| 9    | 1       | 391   | 1    |

递推关系类似：

~~~c
if(a[i]) {
    x[i] = x[i-1] * power[i-1];
}
else x[i] = x[i-1];
power[i] = pow(power[i-1],2);
~~~

最后的结果就是表格右下角的 x 的值

## 模 m 算术运算

### 定义

给定 $$Z_m$$ 是一个包含从 0 到 m-1 的非负整数的集合，即 $$\{0,1,...,m-1\}$$

- 加法 $$+_m$$ 被定义为 $$ a +_m b = (a+b)\bmod m$$ 这是模 m 加法

- 乘法 $$*_m$$ 被定义为 $$a*_m b = (a * b) \bmod m$$ 这是模 m 乘法
- 进行这些运算被称为模 m 的算术运算

### 例题 1

计算 $$ 7+_119$$ 和 $$7*_{11} 9$$

### 解答 1

利用定义可简单计算。略

### 性质

- **封闭性** 如果 a 和 b 属于 $$Z_m$$ ，那么 $$a+_mb$$ 和 $$a*_mb$$ 属于 $$Z_m$$
- **结合律** 如果 a, b 和 c 属于 $$Z_m$$ 
- **交换律** 如果 a 和 b 属于 $$Z_m$$ ，那么 $$ a +_m b = b +_m a$$ 以及 $$ a *_m b = b *_m a$$ 
- **单位元** 0 和 1 分别是模加法和模乘法的单位元

  - 如果 a 属于 $$Z_m$$ ，那么 $$ a  +_m 0 = a$$ 以及 $$a*_m 1 = a$$

- **加法逆元** 如果 $$ a \neq 0$$ 属于 $$Z_m$$ ，那么 m - a 是 a 的 模 m 加法逆元。0 是它自身的模 m 加法逆元。
  - $$ a+_m(m-a) = 0\ \And\ 0 +_m 0 = 0$$

- **分配律** 如果 a, b 和 c 属于 $$Z_m$$ 那么
  - $$a*_m(b+_mc) = (a*_mb)+_m(a*_mc)$$ 以及 $$(a+_mb)*_mc = (a*_m c)+_m(b*_mc)$$

**乘法逆元在模 m 的运算中并不总是存在** 例如，2 在模 6 的情况下没有乘法逆元，因为没有整数 x 使得  $$ 2*x\equiv 1\pmod 6 $$
